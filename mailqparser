#!/usr/bin/env python

from __future__ import with_statement
import argparse
import re
import sys


'''A tool for parsing the output of mailq/postqueue -p/sendmail -bp'''


def multiline_split(iterator, pattern='^$'):
    '''Splits multiline text based on a provided regex and returns the
    result as a generator. When reading from stdin, this turns out to be much
    more efficient than doing something like this:

    re.split('^$', text, re.MULTILINE)
    '''
    block = ''
    regex = re.compile(pattern)
    while True:
        try:
            line = iterator.next()
            if regex.match(line):
                if len(block) > 0:
                    yield block
                block = ''
            else:
                block += line
        except StopIteration:
            yield block
            break


def parse_blocks(blocks):
    '''Parses entries in the mailq and returns the postfix id, sender,
    and recipient of the message
    '''
    regex = re.compile(r"""
        (?P<id>[A-Z0-9]+)             # mail queue id
        \*?                           # asterisk if message is in the active queue
        \s+
        (?P<size>\d+)                 # message size
        \s+
        (?P<date>\w{3}\s\w{3}\s\d\d)  # date stamp (e.g. Sat Mar 14)
        \s
        (?P<stamp>\d\d:\d\d:\d\d)     # timestamp (e.g. 10:12:28)
        \s+
        (?P<sender>.*)                # sender
    """, re.VERBOSE)
    head_pattern = re.compile(r"""-Queue ID- --Size-- ----Arrival Time---- -Sender/Recipient-------""")
    head_seen = False
    for block in blocks:
        mailq_item = {}
        data = block.strip('\n').split('\n')
        if not head_seen and head_pattern.match(data[0]):
            data = data[1:]
            head_seen = True
        header = regex.match(data[0])
        if not header:
            continue
        mailq_item['id'] = header.group('id')
        mailq_item['size'] = header.group('size')
        mailq_item['from'] = header.group('sender')
        mailq_item['datestring'] = ' '.join((header.group('date'), header.group('stamp')))
        mailq_item['to'] = []
        # Todo: parse date/stamp and add mailq_item['stamp'] as a datetime
        # object
        for line in data[1:]:
            line = line.strip()
            # Each entry in the mail queue may or may not have an error or
            # reason it's deferred. This is always in parens
            if line.startswith('(') and line.endswith(')'):
                mailq_item['error'] = line
            else:
                mailq_item['to'].append(line)
        yield mailq_item


def read_pattern_file(fname):
    '''Reads a file and returns a regex object'''
    with open(fname, 'r') as fp:
        pattern = '|'.join(line.strip() for line in fp)
        pattern = pattern.strip('|\n\t ')
        if pattern == '':
            print "ERROR: Empty pattern file specified."
            exit(1)
        return re.compile(pattern)


def pattern_match(regex, queue_item, mode='any', inverse=False):
    '''Given a regex and a queue_item (a dict), returns True or False based on
    if the messages sender/recipients match the regex.

    Kwargs
        mode: choices ['any', 'from', 'to']. Match on both the
              sender/recipient or just one of the two
        inverse: if True, return True only if there is no match
    '''
    sender_match = lambda x: bool(regex.search(x['from']))
    recipient_match = lambda x: any(map(regex.search, x['to']))

    if mode == 'from':
        found_match = sender_match(queue_item)
    elif mode == 'to':
        found_match = recipient_match(queue_item)
    else:
        found_match = any((
                           sender_match(queue_item),
                           recipient_match(queue_item)
                           ))
    return found_match ^ inverse


def format_output(mailq_item, delim, format_string):
    '''Helper function for formatting data in a mailq_item dict'''

    def fmt(item):
        val = mailq_item.get(item, '')
        val = ','.join(val) if isinstance(val, list) else val
        return val

    data = map(fmt, format_string.split(','))
    return delim.join(data)


if __name__ == '__main__':

    parser = argparse.ArgumentParser(
        usage='%(prog)s [OPTIONS]'
    )
    parser.add_argument(
        '-p', '--print-format',
        dest='print_format',
        default='id,from,to',
        help='''Comma-delimited list of output fields and order. Fields \
available: id, from, to, datestring, size, error. Default is "id,from,to"''',
    )
    parser.add_argument(
        '-d', '--delim',
        dest='delim',
        default=';',
        help='Output field separator to use (default is a semicolon)'
    )
    parser.add_argument(
        '-v',
        dest='inverse',
        action='store_true',
        default=False,
        help='Invert the match (like "grep -v")',
    )
    parser.add_argument(
        '-m', '--match',
        dest='match',
        choices=['any','from','to'],
        default='any',
        help='Match against sender or recipient (default any)'
    )
    group = parser.add_mutually_exclusive_group()
    group.add_argument(
        '-f', '--file',
        dest='pattern_file',
        help='Filename to use for patterns',
    )
    group.add_argument(
        '-r', '--regex',
        dest='pattern',
        help='Regular expression to match queue items against'
    )

    args = parser.parse_args()

    if args.pattern_file:
        try:
            regex = read_pattern_file(args.pattern_file)
        except IOError:
            print "You dingus, your pattern file ({0}) does not exist or isn't readable".format(args.pattern_file)
            exit(1)
    elif args.pattern:
        if args.pattern.endswith('|') or args.pattern.startswith('|'):
            args.pattern = args.pattern.strip('|')
            warning = '''WARNING: Leading or trailing pipe character spotted \
and removed. Are you sure you typed your pattern in correctly?\n'''
            sys.stderr.write(warning)
        regex = re.compile(args.pattern)
    else:
        regex = None

    stdin_lines = (line for line in sys.stdin)
    split_data = multiline_split(stdin_lines)
    parsed = parse_blocks(split_data)
    filtered = parsed
    if regex:
        filtered = (q for q in filtered if pattern_match(regex, q,
                                                         mode=args.match,
                                                         inverse=args.inverse))
    # A try-except block is necessary here in order to handle ctrl-c or a pipe
    # closure when we pipe stdout to another script/tool
    try:
        for mailq in filtered:
            outstring = format_output(mailq, args.delim, args.print_format)
            sys.stdout.write(outstring + '\n')
    except (IOError, KeyboardInterrupt):
        exit(0)
